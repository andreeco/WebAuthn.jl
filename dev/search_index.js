var documenterSearchIndex = {"docs":
[{"location":"api/#Index","page":"API","title":"Index","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#WebAuthn.WebAuthn","page":"API","title":"WebAuthn.WebAuthn","text":"module WebAuthn\n\nA Julia package for WebAuthn/FIDO2 credential registration and authentication in web applications.\n\nSupports all required cryptographic formats: CBOR/COSE, Ed25519 (OKP), ECDSA (P-256), RSA public keys, base64url, and PEM export. Utility functions simplify browser-challenge generation, and parsing and verification of registration and authentication responses.\n\n\n\n\n\n","category":"module"},{"location":"api/#WebAuthn.EC2PublicKey","page":"API","title":"WebAuthn.EC2PublicKey","text":"struct EC2PublicKey\n\nRepresent a COSE kty=2 EC2 public key (P-256/ES256).\n\nFields:\n\nx::Vector{UInt8}  # x coordinate\ny::Vector{UInt8}  # y coordinate\nalg::Int          # COSE alg, usually -7\ncrv::Int          # COSE curve, usually 1 (P-256)\n\nSee also: RSAPublicKey and OKPPublicKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAuthn.OKPPublicKey","page":"API","title":"WebAuthn.OKPPublicKey","text":"struct OKPPublicKey\n\nRepresent a COSE kty=1 OKP public key (Ed25519).\n\nFields:\n\nx::Vector{UInt8}  # public key bytes\nalg::Int          # COSE alg, usually -8\ncrv::Int          # COSE curve ID, usually 6\n\nSee also: EC2PublicKey and RSAPublicKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAuthn.RSAPublicKey","page":"API","title":"WebAuthn.RSAPublicKey","text":"struct RSAPublicKey\n\nRepresent a COSE kty=3 RSA public key.\n\nFields:\n\nn::Vector{UInt8}  # modulus\ne::Vector{UInt8}  # exponent\nalg::Int          # COSE alg, usually -257\n\nSee also: EC2PublicKey and OKPPublicKey.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAuthn.WebAuthnPublicKey","page":"API","title":"WebAuthn.WebAuthnPublicKey","text":"abstract type WebAuthnPublicKey\n\nAbstract supertype for all WebAuthn public key structs.\n\n\n\n\n\n","category":"type"},{"location":"api/#WebAuthn.asset-Tuple{AbstractString}","page":"API","title":"WebAuthn.asset","text":"asset(name::AbstractString)::String\n\nRead and return the contents of an asset script (e.g. JS file) shipped  with WebAuthn.jl. Example: WebAuthn.asset(\"webauthn_register.js\")\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.asset_path-Tuple{AbstractString}","page":"API","title":"WebAuthn.asset_path","text":"asset_path(name::AbstractString)::String\n\nGet absolute path to an asset shipped with WebAuthn.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.authentication_options-Tuple{String}","page":"API","title":"WebAuthn.authentication_options","text":"authentication_options(rpid; allow_credential_ids=[], \n    challenge=nothing, timeout=60000, kwargs...)::Dict\n\nBuild a browser authentication options dictionary for  navigator.credentials.get.\n\nKeywords\n\nallow_credential_ids: List of credential IDs (strings) that are allowed   (default: empty).\nchallenge: Challenge string to use (default: random).\ntimeout: Timeout in milliseconds (default: 60000).\nkwargs: Any additional field for WebAuthn/PublicKeyCredentialRequestOptions;   future extensions or browser-specific options can be passed directly as   keywords.\n\nExamples\n\njulia> using WebAuthn\n\njulia> opts = authentication_options(\"example.com\";\n           allow_credential_ids=[\"id1\", \"id2\"], userVerification=\"required\", \n           extensions=Dict(\"appid\"=>true));\n\njulia> opts[\"rpId\"]\n\"example.com\"\n\njulia> opts[\"allowCredentials\"][1][\"id\"]\n\"id1\"\n\njulia> opts[\"userVerification\"]\n\"required\"\n\njulia> opts[\"extensions\"][\"appid\"]\ntrue\n\nSee also: registration_options.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.base64urldecode-Tuple{AbstractString}","page":"API","title":"WebAuthn.base64urldecode","text":"base64urldecode(s::AbstractString)::Vector{UInt8}\n\nDecode a base64url string (URL-safe, no padding) to a byte vector.\n\nRestores standard base64 alphabet and adds padding if necessary before decoding.\n\nExamples\n\njulia> using WebAuthn\n\njulia> base64urldecode(\"AQID\")\n3-element Vector{UInt8}:\n 0x01\n 0x02\n 0x03\n\nSee also: base64urlencode.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.base64urlencode-Tuple{Vector{UInt8}}","page":"API","title":"WebAuthn.base64urlencode","text":"base64urlencode(bytes::Vector{UInt8})::String\n\nEncode a byte vector to a base64url string without padding.\n\nReplaces + with - and / with _ for URL safety, then removes padding characters.\n\nExamples\n\njulia> using WebAuthn\n\njulia> base64urlencode(UInt8[1, 2, 3])\n\"AQID\"\n\nSee also: base64urldecode.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.cose_key_parse-Tuple{Dict}","page":"API","title":"WebAuthn.cose_key_parse","text":"cose_key_parse(cose::Dict)::WebAuthnPublicKey\n\nParse a COSE_Key dictionary to the appropriate public key struct.\n\nExamples\n\njulia> using WebAuthn\n\njulia> x = UInt8[0x2b, 0x80, 0x96, 0x04, 0x72, 0x26, 0x46, 0x00, 0x15, 0x3d, \n                 0x7a, 0xe6, 0x50, 0x3e, 0xd5, 0x84, 0xd1, 0x56, 0xd6, 0xc5, \n                 0x2c, 0x18, 0x8d, 0x7b, 0xb6, 0xf6, 0x8d, 0xe8, 0xa1, 0x24, \n                 0x06, 0xe9];\n\njulia> y = UInt8[0x1d, 0x3a, 0x3f, 0x1c, 0x5e, 0x76, 0x52, 0x9e, 0x11, 0x6e, \n                 0x3e, 0xb7, 0xfc, 0x6a, 0x33, 0xfc, 0x2a, 0xb4, 0x68, 0x62, \n                 0x26, 0x6a, 0x1d, 0x51, 0x72, 0xf3, 0x3c, 0xab, 0x3c, 0x9c, \n                 0xc5, 0x9f];\n\njulia> cose = Dict(1=>2, 3=>-7, -1=>1, -2=>x, -3=>y);\n\njulia> key = cose_key_parse(cose);\n\njulia> key isa WebAuthn.EC2PublicKey\ntrue\n\nSee also: EC2PublicKey, RSAPublicKey and  OKPPublicKey.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.cose_key_to_pem-Tuple{WebAuthnPublicKey}","page":"API","title":"WebAuthn.cose_key_to_pem","text":"cose_key_to_pem(key::WebAuthnPublicKey)::String\n\nConvert a WebAuthn public key struct to PEM SubjectPublicKeyInfo string.\n\nCreates a standard PEM format public key from a parsed WebAuthn/COSE public key (e.g., EC2PublicKey, RSAPublicKey, or OKPPublicKey) for use with external cryptographic libraries.\n\nExamples\n\njulia> using WebAuthn\n\njulia> key = EC2PublicKey(rand(UInt8,32), rand(UInt8,32), -7, 1);\n\njulia> pem = cose_key_to_pem(key);\n\nSee also: cose_key_parse.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.der_to_pem","page":"API","title":"WebAuthn.der_to_pem","text":"der_to_pem(derbytes::Vector{UInt8}, label::String = \"CERTIFICATE\")::String\n\nConvert DER-encoded bytes to a PEM string with the specified label.\n\nFormats binary DER data as a PEM-encoded string, splitting base64 lines to 64 characters and adding header and footer lines for the given type.\n\nExamples\n\njulia> using WebAuthn\n\njulia> der = [\n           0x30,0x59,0x30,0x13,0x06,0x07,0x2A,0x86,0x48,0xCE,0x3D,0x02,0x01,\n           0x06,0x08,0x2A,0x86,0x48,0xCE,0x3D,0x03,0x01,0x07,0x03,0x42,0x00,\n           0x04,0xac,0x21,0x45,0xb3,0x77,0x1d,0xdd,0xab,0xbd,0x1c,0x34,0x5e,\n           0xed,0x9d,0x6a,0x81,0xd9,0x32,0x42,0xe0,0xaf,0xf4,0x77,0x07,0xf0,\n           0x65,0x64,0x69,0xae,0x95,0x50,0xfe,0x86,0x21,0xba,0xcf,0xb5,0x43,\n           0xaf,0x90,0xe2,0xda,0xf4,0x2f,0x9f,0x9b,0x71,0x09,0x55,0x7a,0x53,\n           0xc3,0x63,0x1e,0xb9,0xa9,0x3f,0xfb,0x66,0x32,0xfa,0x3a,0x49,0x01,\n           0x01 ];\n\njulia> pem = WebAuthn.der_to_pem(der);\n\nSee also: cose_key_to_pem.\n\n\n\n\n\n","category":"function"},{"location":"api/#WebAuthn.enforce_signcount-Tuple{Integer, Integer}","page":"API","title":"WebAuthn.enforce_signcount","text":"enforce_signcount(old::Integer, new::Integer)\n\nReject cloned/replayed credentials per WebAuthn spec.\n\nExamples\n\njulia> enforce_signcount(0, 20)   # Initial use, old is 0: always OK\ntrue\n\njulia> enforce_signcount(10, 11)  # Normal monotonic increase\ntrue\n\njulia> enforce_signcount(5, 5)    # No increase (should fail)\nERROR: ArgumentError: \n[...]\n\njulia> enforce_signcount(10, 3)   # Replay/clone (should fail)\nERROR: ArgumentError: \n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.enforce_up_uv-Tuple{Vector{UInt8}}","page":"API","title":"WebAuthn.enforce_up_uv","text":"enforce_up_uv(authData::Vector{UInt8}; require_uv=false)\n\nCheck user presence (UP) and user verification (UV) flags in authenticatorData.\n\nExamples\n\n```jldoctest julia> # UP (bit 0) set, UV (bit 2) not set\n\njulia> enforceupuv([zeros(UInt8,33); 0x01]) true\n\njulia> # UP and UV set\n\njulia> enforceupuv([zeros(UInt8,33); 0x05]) true\n\njulia> # UP not set\n\njulia> enforceupuv([zeros(UInt8,33); 0x00]) ERROR:  [...]\n\njulia> # UP set, require UV (but UV not set)\n\njulia> enforceupuv([zeros(UInt8,33); 0x01]; require_uv=true) ERROR:  [...]\n\njulia> # UP and UV set, require UV (pass)\n\njulia>  enforceupuv([zeros(UInt8,33); 0x05]; require_uv=true) true\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.extract_credential_public_key-Tuple{Vector{UInt8}}","page":"API","title":"WebAuthn.extract_credential_public_key","text":"extract_credential_public_key(authData::Vector{UInt8})::Vector{UInt8}\n\nExtract the credential public key bytes from authenticator data.\n\nReturns the raw CBOR-encoded public key (COSE_Key) after parsing  authData as specified by the WebAuthn/FIDO2 standard.\n\nExamples\n\njulia> using WebAuthn\n\njulia> fake_pk = UInt8[0xa5, 0x01, 0x02, 0x03, 0x38, 0x20, 0x01, 0x33, 0x58, \n       0x20];\n\njulia> authData = vcat(zeros(UInt8, 37+16), \n       0x00, 0x10, rand(UInt8, 16), fake_pk);\n\njulia> pkbytes = extract_credential_public_key(authData);\n\nSee also: parse_credential_public_key\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.generate_challenge","page":"API","title":"WebAuthn.generate_challenge","text":"generate_challenge([n=32])::String\n\nGenerate a random base64url-encoded challenge of n bytes.\n\nExamples\n\njulia> using WebAuthn\n\njulia> challenge = generate_challenge();\n\njulia> length(base64urldecode(challenge))\n32\n\n\n\n\n\n","category":"function"},{"location":"api/#WebAuthn.parse_assertion-Tuple{AbstractString, AbstractString}","page":"API","title":"WebAuthn.parse_assertion","text":"parse_assertion(authdata_b64, sig_b64) -> (authData, signature)\n\nBase64url-decode authenticatorData and signature as a tuple of byte vectors.\n\nReturns the authenticator data and signature, each as a vector of bytes.\n\nExamples\n\njulia> using WebAuthn\n\njulia> ad_b64 = base64urlencode(rand(UInt8, 37));\n\njulia> sig_b64 = base64urlencode(rand(UInt8, 64));\n\njulia> ad, sig = parse_assertion(ad_b64, sig_b64);\n\nSee also: parse_attestation_object and parse_clientdata_json.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_attestation_object-Tuple{String}","page":"API","title":"WebAuthn.parse_attestation_object","text":"parse_attestation_object(b64::String)::Dict\n\nParse a base64url-encoded attestationObject to a dictionary.\n\nDecodes and parses the CBOR-encoded attestation object returned during  WebAuthn registration.\n\nExamples\n\njulia> using WebAuthn, CBOR\n\njulia> attObj_b64 =\n           \"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVikgokmRebwXda2X9CScZAt1\" *\n           \"FS1U7jvFi6aDLY8eyICQjhBAAAAAcDiKS6EGVQBSZ3UWJ8FVioAIJYypOb6RxF\" *\n           \"Q4ocIvwK78qeEYp67CAWrj59jW99h8_tNpQECAyYgASFYIOyFijz315Yd_Aexkt\" *\n           \"5l6YaFK4MK2CQgRZPXQqGGD06MIlgg54dhMxLg9u84Y3urvWdHrViXea0aMYq7v\" *\n           \"7QI-DP1Duk\";\n\njulia> obj = parse_attestation_object(attObj_b64);\n\nSee also: parse_clientdata_json.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_clientdata_json-Tuple{String}","page":"API","title":"WebAuthn.parse_clientdata_json","text":"parse_clientdata_json(b64::String)::Dict\n\nParse a base64url-encoded clientDataJSON to a dictionary.\n\nDecodes the clientDataJSON, converting from base64url and UTF-8 JSON to a  Julia dictionary.\n\nExamples\n\njulia> using WebAuthn\n\njulia> json = \"\"\"{\"type\": \"webauthn.get\"}\"\"\";\n\njulia> cdj_b64 = base64urlencode(Vector{UInt8}(json));\n\njulia> cdj = parse_clientdata_json(cdj_b64)\nDict{String, Any} with 1 entry:\n  \"type\" => \"webauthn.get\"\n\nSee also: parse_attestation_object.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_credential_public_key-Tuple{Vector{UInt8}}","page":"API","title":"WebAuthn.parse_credential_public_key","text":"parse_credential_public_key(authData::Vector{UInt8})::WebAuthnPublicKey\n\nExtract and parse credential public key from authenticator data.\n\nReads the CBOR-encoded credentialPublicKey field from authData and returns the corresponding parsed struct (e.g., EC2PublicKey, RSAPublicKey, or OKPPublicKey).\n\nExamples\n\njulia> using WebAuthn, CBOR\n\njulia> x = UInt8[0x2b, 0x80, 0x96, 0x04, 0x72, 0x26, 0x46, 0x00, 0x15, 0x3d, \n                 0x7a, 0xe6, 0x50, 0x3e, 0xd5, 0x84, 0xd1, 0x56, 0xd6, 0xc5, \n                 0x2c, 0x18, 0x8d, 0x7b, 0xb6, 0xf6, 0x8d, 0xe8, 0xa1, 0x24, \n                 0x06, 0xe9];\n\njulia> y = UInt8[0x1d, 0x3a, 0x3f, 0x1c, 0x5e, 0x76, 0x52, 0x9e, 0x11, 0x6e, \n                 0x3e, 0xb7, 0xfc, 0x6a, 0x33, 0xfc, 0x2a, 0xb4, 0x68, 0x62, \n                 0x26, 0x6a, 0x1d, 0x51, 0x72, 0xf3, 0x3c, 0xab, 0x3c, 0x9c, \n                 0xc5, 0x9f];\n\njulia> fake_pk = CBOR.encode(Dict(1 => 2, 3 => -7, -1 => 1, -2 => x, -3 => y));\n\njulia> authData = vcat(zeros(UInt8, 37+16), 0x00, 0x20, rand(UInt8, 32), fake_pk);\n\n\njulia> key = parse_credential_public_key(authData);\n\njulia> key isa WebAuthn.EC2PublicKey\ntrue\n\nSee also: extract_credential_public_key and cose_key_parse.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_ec_pem_xy-Tuple{AbstractString}","page":"API","title":"WebAuthn.parse_ec_pem_xy","text":"parse_ec_pem_xy(pem::AbstractString)\n\nExtract XY EC coordinates from a PEM/SPKI P-256 public key.\n\nParses a PEM-encoded (or plain DER) SubjectPublicKeyInfo containing a  P-256 (secp256r1) uncompressed EC public key, as produced for WebAuthn and  most browsers or OpenSSL tools. Returns X and Y coordinates of the EC point,  each as a 32-byte vector.\n\nHandles both short- and long-form DER length encodings, and scans all  BIT STRING tags for an uncompressed point (0x04 prefix, 65 bytes total).  Raises an error if not found.\n\nExample\n\njulia> using WebAuthn\n\njulia> pem = \"\"\"\n       -----BEGIN PUBLIC KEY-----\n       MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEK4CWBHImRgAVPXrmUD7VhNFW1sUs\n       GI17tvaN6KEkBukdOj8cXnZSnhFuPrf8ajP8KrRoYiZqHVFy8zyrPJzFnw==\n       -----END PUBLIC KEY-----\n       \"\"\";\n\njulia> x, y = parse_ec_pem_xy(pem);\n\njulia> length(x), length(y)\n(32, 32)\n\nSee also: pem_to_der, parse_rsa_pem_ne and parse_ed25519_pem_x.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_ed25519_pem_x-Tuple{AbstractString}","page":"API","title":"WebAuthn.parse_ed25519_pem_x","text":"parse_ed25519_pem_x(pem::AbstractString)::x::Vector{UInt8}\n\nExtract the x-coordinate (32 bytes) from an Ed25519 public key (PEM/SPKI).\n\nParses a PEM-encoded Ed25519 SubjectPublicKeyInfo as generated by OpenSSL or  Python and returns the 32-byte raw public key (x). This is useful for verifying Ed25519 signatures.\n\nExample\n\njulia> using WebAuthn\n\njulia> pem = \"\"\"\n       -----BEGIN PUBLIC KEY-----\n       MCowBQYDK2VwAyEAoi3rnmJUD+qXNlp2pBkQWpXCUUjccW+6Ue5r0QDPF94=\n       -----END PUBLIC KEY-----\n       \"\"\";\n\njulia> x = parse_ed25519_pem_x(pem);\n\njulia> length(x)\n32\n\nSee also: pem_to_der and parse_ec_pem_xy.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.parse_rsa_pem_ne-Tuple{AbstractString}","page":"API","title":"WebAuthn.parse_rsa_pem_ne","text":"parse_rsa_pem_ne(pem::AbstractString)\n\nExtract the modulus (n) and exponent (e) from an RSA public key (PEM/SPKI).\n\nReads a PEM-encoded RSA SubjectPublicKeyInfo (as produced by OpenSSL,  browser tools, etc.) and returns the modulus and exponent as byte vectors  suitable for cryptographic use.\n\nRaises an error if the ASN.1 structure is unexpected or unsupported.\n\nExample\n\njulia> using WebAuthn\n\njulia> pem = \"\"\"\n       -----BEGIN PUBLIC KEY-----\n       MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA2auHrQvvpQv/DI1wQAmd\n       YCUYzOr8hWU2rMtDEae/p5Cu5pyNJRdv7DjOdOeWeWq1rA/Od/GY/HYazst1lWMC\n       XjiW3nf0yV1jHoXl9Dc1wFTxl7EKrykK2EsijB8f93f4scxEalIyfjauXC6hIPi4\n       /yWGS8cJOuj35ac/7N6GrUMIdzCj0qumTrUhRkmsJo2HtGm3dKkEZxHnL7fs/hln\n       wwVOl2rqH0EcaVBSZwvjuEt6EfVMhqINp9FhRaIq5gx0ZpBR6OpFPM5oXrtMgsKO\n       vIdZK7yZPcKw0JLmymZMi5gjgGVTX48YHoM8Mi6KtB4k2Rbp3Ouqc56odpLx2K2S\n       cwIDAQAB\n       -----END PUBLIC KEY-----\n       \"\"\";\n\njulia> n, e = parse_rsa_pem_ne(pem);\n\njulia> length(n) > 200 && e == UInt8[0x01, 0x00, 0x01]\ntrue\n\nSee also: pem_to_der and parse_ec_pem_xy.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.pem_to_der-Tuple{AbstractString}","page":"API","title":"WebAuthn.pem_to_der","text":"pem_to_der(pem::AbstractString)::Vector{UInt8}\n\nDecode a PEM-formatted string (e.g., a PEM public key or certificate)  to a DER-encoded byte vector.\n\nStrips header/footer and whitespace, decodes the enclosed base64.\n\nExample\n\njulia> using WebAuthn\n\njulia> pem = \"\"\"\n       -----BEGIN PUBLIC KEY-----\n       MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgAEK4CWBHImRgAVPXrmUD7VhNFW1sUs\n       GI17tvaN6KEkBukdOj8cXnZSnhFuPrf8ajP8KrRoYiZqHVFy8zyrPJzFnw==\n       -----END PUBLIC KEY-----\n       \"\"\";\n\njulia> der = WebAuthn.pem_to_der(pem);\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.registration_options-Tuple{String, String, Any, String, String}","page":"API","title":"WebAuthn.registration_options","text":"registration_options(rpid, rpname, user_id, user_name, user_display;\n    exclude_ids=[], challenge=nothing,\n    attestation=\"none\", timeout=60000, kwargs...)::Dict\n\nConstruct WebAuthn registration options for navigator.credentials.create.\n\nArguments\n\nrpid: relying party identifier (e.g., \"example.com\").\nrpname: display name of the RP.\nuser_id: user handle (string or byte vector).\nuser_name: username (string).\nuser_display: display name (string).\n\nKeywords\n\nexclude_ids: vector of credential IDs to exclude (default empty).\nchallenge: challenge string to use (default: random).\nattestation: \"none\" (default), \"packed\", \"direct\", \"enterprise\", etc.\ntimeout: timeout in ms (default 60000).\nkwargs: any additional WebAuthn/PublicKeyCredentialCreationOptions fields;  future extensions can be set directly as keywords.\n\nExamples\n\njulia> using WebAuthn\n\njulia> opts = registration_options(\"foo.com\", \"Demo\", 123, \"bob\", \n           \"Bob\", attestation=\"packed\", extensions=Dict(\"my_custom\"=>\"hi\"));\n\njulia> opts[\"attestation\"]\n\"packed\"\n\njulia> opts[\"extensions\"][\"my_custom\"]\n\"hi\"\n\nSee also: authentication_options.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_attestation_object-Tuple{String, Vector{UInt8}}","page":"API","title":"WebAuthn.verify_attestation_object","text":"verify_attestation_object(attObj_b64, clientDataJSON)::Bool\n\nVerify a WebAuthn attestation object of format \"none\" or \"packed\".\n\nExamples\n\njulia> using WebAuthn\n\njulia> attObj_b64 =\n       \"o2NmbXRkbm9uZWdhdHRTdG10oGhhdXRoRGF0YVikgokmRebwXda2X9CScZAt1\" *\n       \"FS1U7jvFi6aDLY8eyICQjhBAAAAAcDiKS6EGVQBSZ3UWJ8FVioAIJYypOb6RxF\" *\n       \"Q4ocIvwK78qeEYp67CAWrj59jW99h8_tNpQECAyYgASFYIOyFijz315Yd_Aexkt\" *\n       \"5l6YaFK4MK2CQgRZPXQqGGD06MIlgg54dhMxLg9u84Y3urvWdHrViXea0aMYq7v\" *\n       \"7QI-DP1Duk\";\n\njulia> cdj_b64 =\n       \"eyJ0eXBlIjoid2ViYXV0aG4uY3JlYXRlIiwiY2hhbGxlbmdlIjoiazF6eV9hU0N\" *\n       \"PTDdOMFBWVmFVVElpVm5BU1ZGVDE4MDB1TWJVa1R2dUdKSSIsIm9yaWdpbiI6Im\" *\n       \"h0dHBzOi8vd2ViYXV0aG4tdGVzdC5sb2NhbCIsImNyb3NzT3JpZ2luIjpmYWxze\" *\n       \"X0\";\n\njulia> clientDataJSON = WebAuthn.base64urldecode(cdj_b64);\n\njulia> ok = verify_attestation_object(attObj_b64, clientDataJSON)\ntrue\n\nSee also: verify_webauthn_signature.\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_attestation_packed-Tuple{Dict, Vector{UInt8}, Vector{UInt8}}","page":"API","title":"WebAuthn.verify_attestation_packed","text":"verify_attestation_packed(attStmt::Dict, msg::Vector{UInt8},\n    authData::Vector{UInt8}[, clientDataJSON::Vector{UInt8}])::Bool\n\nVerify a WebAuthn \"packed\" attestation statement   (e.g., self-attested Ed25519 / ECDSA / RSA, as used in device authentication).\n\nOn success, returns true; otherwise, returns false.   For Ed25519 (OKP, alg -8), the signature must be over SHA256(clientDataJSON)  (not the full authData || SHA256(clientDataJSON)).\n\nExamples\n\njulia> using WebAuthn, CBOR, Sodium, SHA\n\njulia> pk = Vector{UInt8}(undef, Sodium.crypto_sign_PUBLICKEYBYTES);\n\njulia> sk = Vector{UInt8}(undef, Sodium.crypto_sign_SECRETKEYBYTES);\n\njulia> Sodium.crypto_sign_keypair(pk, sk);\n\njulia> cose = Dict(1=>1, 3=>-8, -1=>6, -2=>pk);\n\njulia> cbor_pk = CBOR.encode(cose);\n\njulia> rpId = \"example.com\";\n\njulia> rpIdHash = SHA.sha256(Vector{UInt8}(rpId));\n\njulia> flags = 0x41; signCount = UInt8[0,0,0,1]; aaguid = zeros(UInt8,16);\n\njulia> credId = rand(UInt8,16); credIdLen = [UInt8(length(credId) >> 8), \n           UInt8(length(credId)&0xff)];\n\njulia> authData = vcat(rpIdHash, flags, signCount, aaguid, credIdLen, \n           credId, cbor_pk);\n\njulia> clientDataJSON = b\"\"\"{\"type\":\"webauthn.create\",\"challenge\":\"abc\",\n            \"origin\":\"https://example.com\"}\"\"\";\n\njulia> clientDataHash = SHA.sha256(clientDataJSON);\n\njulia> sig = Vector{UInt8}(undef, Sodium.crypto_sign_BYTES);\n\njulia> sl = Ref{UInt64}();\n\njulia> Sodium.crypto_sign_detached(sig, sl, clientDataHash, \n            length(clientDataHash), sk);\n\njulia> msg = vcat(authData, clientDataHash);\n\njulia> attStmt = Dict(\"sig\"=>sig, \"alg\"=>-8);\n\njulia> verify_attestation_packed(attStmt, msg, authData)\ntrue\n\njulia> attStmt_bad = deepcopy(attStmt); attStmt_bad[\"sig\"][1] ⊻= 0xFF;\n\njulia> verify_attestation_packed(attStmt_bad, msg, authData)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_challenge-Tuple{AbstractString, AbstractString}","page":"API","title":"WebAuthn.verify_challenge","text":"verify_challenge(clientDataJSON_b64, expected_challenge_b64)::Bool\n\nVerify the clientDataJSON challenge matches the expected challenge.\n\nExamples\n\njulia> using WebAuthn, JSON3\n\njulia> challenge = generate_challenge(16);\n\njulia> cdj = JSON3.write(Dict(\"type\"=>\"webauthn.create\",\n            \"challenge\"=>challenge, \"origin\"=>\"https://site\"));\n\njulia> cdj_b64 = base64urlencode(Vector{UInt8}(cdj));\n\njulia> verify_challenge(cdj_b64, challenge)\ntrue\n\nSee also: generate_challenge\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_origin-Tuple{Dict, String}","page":"API","title":"WebAuthn.verify_origin","text":"verify_origin(cdj::Dict, expected::String)\n\nCheck that the 'origin' field in the parsed clientDataJSON matches what you  expect.\n\nExamples\n\njulia> verify_origin(Dict(\"origin\" => \"https://demo.test\"), \"https://demo.test\")\ntrue\n\njulia> verify_origin(Dict(\"origin\" => \"https://evil.site\"), \"https://demo.test\")\nERROR: ArgumentError: \n[...]\n\njulia> # If 'origin' key is missing in dict\n\njulia> verify_origin(Dict(\"foo\" => 42), \"https://demo.test\")\nERROR: ArgumentError: \n[...]\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_p256_signature_raw_xy-NTuple{4, Vector{UInt8}}","page":"API","title":"WebAuthn.verify_p256_signature_raw_xy","text":"verify_p256_signature_raw_xy(x, y, digest, sig)::Bool\n\nVerify a P-256 ECDSA sig with OpenSSL using raw pubkey XY, SHA256 digest,  and DER-encoded signature.\n\nExamples\n\njulia> using WebAuthn, SHA\n\njulia> x = UInt8[\n           0x7d, 0xf1, 0xb2, 0x85, 0x1d, 0xdc, 0x04, 0x29,\n           0xdf, 0x71, 0xbd, 0x49, 0x9f, 0xea, 0x1d, 0xef,\n           0xca, 0x63, 0x4c, 0x5c, 0xbe, 0x8e, 0xaa, 0xa5,\n           0xcd, 0x3b, 0xa6, 0x65, 0xb7, 0xba, 0x3e, 0x32\n       ];\n\njulia> y = UInt8[\n           0x6e, 0x33, 0x03, 0x54, 0xd9, 0x5f, 0x0d, 0xb7,\n           0x28, 0x69, 0xec, 0x9a, 0x47, 0x82, 0x99, 0xe4,\n           0xe9, 0x34, 0x44, 0xe4, 0x8d, 0x40, 0x8f, 0xbe,\n           0xa1, 0x61, 0xf9, 0x3a, 0x4f, 0xd2, 0x14, 0xb8\n       ];\n\njulia> msg    = b\"test message\";\n\njulia> digest = SHA.sha256(msg);\n\njulia> sig = UInt8[\n           0x30, 0x45, 0x02, 0x21, 0x00, 0xa9, 0xe7, 0x2a,\n           0x18, 0x6a, 0xe2, 0xa3, 0x5d, 0x7a, 0x34, 0xa2,\n           0x60, 0xef, 0xff, 0x36, 0x27, 0xbb, 0x59, 0x31,\n           0xf9, 0xe3, 0xdb, 0xe5, 0xf8, 0x0a, 0xa2, 0xff,\n           0x3f, 0xad, 0x2e, 0x3c, 0x79, 0x02, 0x20, 0x74,\n           0x24, 0x4a, 0xb1, 0x19, 0xf2, 0x70, 0x4f, 0xa2,\n           0x62, 0xdc, 0x87, 0x6c, 0x6b, 0xeb, 0xda, 0x77,\n           0xe1, 0x5a, 0x5a, 0x13, 0xb9, 0xec, 0x87, 0x4e,\n           0x29, 0x4b, 0x25, 0x95, 0x83, 0xc9, 0xdf];\n\njulia> WebAuthn.verify_p256_signature_raw_xy(x, y, digest, sig)\ntrue\n\njulia> sig2 = copy(sig); sig2[1] ⊻= 0xFF;\n\njulia> WebAuthn.verify_p256_signature_raw_xy(x, y, digest, sig2)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_rsa_signature_raw_ne-NTuple{4, Vector{UInt8}}","page":"API","title":"WebAuthn.verify_rsa_signature_raw_ne","text":"verify_rsa_signature_raw_ne(n, e, digest, sig)::Bool\n\nVerify an RSA PKCS1v1.5/SHA256 signature using raw modulus and exponent buffers,  with everything in memory.\n\nExamples\n\njulia> using WebAuthn, SHA, Test\n\njulia> n = UInt8[0xc8,0xac,0xb4,0xd0,0x1c,0x87,0x78,0x45,0x1d,0xcc,0xfa,\n                 0xee,0x0a,0xe1,0x38,0xb4,0x12,0x71,0xf2,0x85,0x9d,0x00,\n                 0xb1,0xf8,0x01,0x74,0x01,0xb9,0xcc,0x8f,0x02,0xda,0x6b,\n                 0xa3,0x7a,0xe3,0xd8,0x35,0x00,0x63,0x52,0x16,0x4e,0xfc,\n                 0xe3,0x8b,0xd0,0x88,0x8e,0xa8,0x03,0x6c,0x56,0x38,0x1f,\n                 0x85,0xfd,0xf4,0xc0,0xa4,0x5b,0x6c,0x3f,0x0d];\n\njulia> e = UInt8[0x01, 0x00, 0x01];\n\njulia> msg = b\"hello RSA\";\n\njulia> digest = SHA.sha256(msg);\n\njulia> sig = UInt8[0x15,0xe4,0xed,0xd0,0x0a,0xe1,0x62,0xda,0xe5,0x84,0xb6,\n                   0x9c,0x91,0x96,0x5e,0xba,0xa8,0x3a,0x01,0x55,0xc5,0x6e,\n                   0x06,0xce,0xd5,0xd1,0x02,0x49,0x17,0x4c,0xb4,0xbf,0x36,\n                   0x77,0x88,0x48,0x46,0x59,0x2e,0xd9,0xac,0x3e,0xcd,0x83,\n                   0x69,0xab,0x46,0x8a,0xfe,0xa8,0xd0,0xee,0x1f,0x9c,0xfd,\n                   0xe1,0xd9,0x03,0x57,0x70,0x34,0xe5,0x80,0xeb];\n\njulia> WebAuthn.verify_rsa_signature_raw_ne(n, e, digest, sig)\ntrue\n\njulia> sig_bad = copy(sig);\n\njulia> sig_bad[1] ⊻= 0xFF;\n\njulia> WebAuthn.verify_rsa_signature_raw_ne(n, e, digest, sig_bad)\nfalse\n\n\n\n\n\n","category":"method"},{"location":"api/#WebAuthn.verify_webauthn_signature","page":"API","title":"WebAuthn.verify_webauthn_signature","text":"verify_webauthn_signature(key_or_pem, authenticatorData, \n    clientDataJSON)::Bool\n\nVerify a WebAuthn assertion signature for the given public key or PEM.\n\nExamples\n\njulia> using WebAuthn, Sodium, SHA\n\njulia> pk = Vector{UInt8}(undef, Sodium.crypto_sign_PUBLICKEYBYTES);\n\njulia> sk = Vector{UInt8}(undef, Sodium.crypto_sign_SECRETKEYBYTES);\n\njulia> Sodium.crypto_sign_keypair(pk, sk);\n\njulia> key = OKPPublicKey(pk, -8, 6);\n\njulia> ad = rand(UInt8, 37);\n\njulia> cdj = rand(UInt8, 32);\n\njulia> msg = vcat(ad, SHA.sha256(cdj));\n\njulia> sig = Vector{UInt8}(undef, Sodium.crypto_sign_BYTES);\n\njulia> sl = Ref{Culonglong}();\n\njulia> Sodium.crypto_sign_detached(sig, sl, msg, length(msg), sk);\n\njulia> valid = verify_webauthn_signature(key, ad, cdj, sig)\ntrue\n\nSee also: cose_key_to_pem and parse_assertion.\n\n\n\n\n\n","category":"function"},{"location":"#WebAuthn.jl","page":"Home","title":"WebAuthn.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WebAuthn.jl brings passkey and FIDO2/WebAuthn authentication to Julia web servers.   It provides end-to-end functions for registration and login, CBOR/COSE key parsing, challenge signing, signature verification, and PEM export.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"warning: Experimental\nThis code is experimental. All cryptographic validation is enforced by OpenSSL or Sodium for safety. Please do not use in production without a full security review.","category":"page"},{"location":"#Features","page":"Home","title":"Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CBOR/COSE key parsing (P-256, RSA, Ed25519)\nBase64url encode/decode & random challenge generator\nRegistration and authentication options utilities\nSecure signature and challenge verification\nPEM export of public keys","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Getting-Started","page":"Home","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Install this package:\n] add WebAuthn\nImport into your Julia session:\nusing WebAuthn\nFor Demo Server Example below:  \n] add HTTP, Sockets, JSON3, WebAuthn, Random, CBOR","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#How-WebAuthn-Works","page":"Home","title":"How WebAuthn Works","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"WebAuthn enables passwordless, phishing-resistant authentication using public-key cryptography.   A passkey (credential) is generated and stored securely on the user device; private keys never leave the device.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Registration-Workflow","page":"Home","title":"Registration Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Server generates options:   registration_options — builds challenge and metadata for browser.\nClient creates credential:   Browser and authenticator generate a new passkey on the device.\nAuthenticator returns attestation:   Browser returns attestationObject and clientDataJSON to your server.\nServer verifies registration:  \nParse: parse_attestation_object, parse_clientdata_json\nCheck challenge: verify_challenge\nExtract public key: extract_credential_public_key, cose_key_parse\n(Optional) Validate attestation: verify_attestation_object  \nStore credential ID & public key for future logins.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Authentication-Workflow","page":"Home","title":"Authentication Workflow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"","page":"Home","title":"Home","text":"Server generates assertion options:   authentication_options\nClient signs with passkey:   Browser prompts user; authenticator signs challenge.\nAuthenticator returns assertion:   Server receives: authenticator data, clientDataJSON, signature.\nServer verifies signature:  \nParse: parse_assertion, parse_clientdata_json\nVerify challenge: verify_challenge\nSignature check: verify_webauthn_signature  \n(Optional) Enforce signCount, user presence, user verification","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Core-Functions-by-Flow","page":"Home","title":"Core Functions by Flow","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Phase Step WebAuthn.jl Functions\nRegistration Build options registration_options\n Parse & verify parse_attestation_object, parse_clientdata_json,verify_challenge, extract_credential_public_key, cose_key_parse, verify_attestation_object\nAuthentication Build options authentication_options\n Parse & verify parse_assertion, parse_clientdata_json, verify_challenge, verify_webauthn_signature","category":"page"},{"location":"","page":"Home","title":"Home","text":"See also: cose_key_to_pem for PEM export/interoperation.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Tips","page":"Home","title":"Tips","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"All crypto uses OpenSSL_jll and Sodium.jl.\nAlways verify the challenge and client origin in every response.\nCheck signCount to stop replay or clone attacks.\nFor user presence/verification, check flags in authenticator data (see FIDO2 spec).","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Demo-Server-Example","page":"Home","title":"Demo Server Example","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Below is a reference implementation of a simple web server. It serves HTML/JS assets, builds and verifies WebAuthn flows, and manages user  passkeys in memory.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Demo screenshots:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: )","category":"page"},{"location":"#How-to-Test-WebAuthn-with-a-Security-Key-or-Phone","page":"Home","title":"How to Test WebAuthn with a Security Key or Phone","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"With hardware key:   Insert device, use when prompted.\nWith smartphone (virtual security key):  \nEnable Bluetooth on computer and phone and connect them\nVisit demo site in Chrome; choose \"Use phone\" when prompted\nScan QR code on screen and follow prompts on your phone","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Full-Example-Server","page":"Home","title":"Full Example Server","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"After installing the dependencies, you can copy-paste this code.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using HTTP, Sockets, JSON3, WebAuthn, Random, CBOR\n\nUSERS = Dict{String,Dict{Symbol,Any}}()\nCREDENTIALS = Dict{String,Dict{Symbol,Any}}()\nrouter = HTTP.Router()\n\nfunction serve_login_success(req)\n    params = HTTP.queryparams(req)\n    username = get(params, \"username\", \"\")\n    html = replace(WebAuthn.asset(\"login_success.html\"),\n        \"{{USERNAME}}\" => HTTP.escapehtml(username))\n    return HTTP.Response(200, [\"Content-Type\" => \"text/html\"], html)\nend\nHTTP.register!(router, \"GET\", \"/login_success\", serve_login_success)\n\nfunction serve_index(req)\n    HTTP.Response(200, [\"Content-Type\" => \"text/html\"],\n        WebAuthn.asset(\"index.html\"))\nend\nHTTP.register!(router, \"GET\", \"/\", serve_index)\n\nfunction serve_webauthn_register_js(req)\n    HTTP.Response(200, [\"Content-Type\" => \"application/javascript\"],\n        WebAuthn.asset(\"webauthn_register.js\"))\nend\nHTTP.register!(router, \"GET\", \"/webauthn_register.js\",\n    serve_webauthn_register_js)\n\nfunction serve_webauthn_login_js(req)\n    HTTP.Response(200, [\"Content-Type\" => \"application/javascript\"],\n        WebAuthn.asset(\"webauthn_login.js\"))\nend\nHTTP.register!(router, \"GET\", \"/webauthn_login.js\", serve_webauthn_login_js)\n\n# Registration options endpoint (browser calls before registration)\nfunction serve_regoptions(req)\n    q = HTTP.queryparams(req)\n    username = get(q, \"username\", \"\")\n    if isempty(username)\n        charset = vcat('A':'Z', 'a':'z', '0':'9')\n        username = join(rand(charset, 8))\n    end\n    opts = WebAuthn.registration_options(\n        \"localhost\", \"Passkey Demo\", username, username, username;\n        exclude_ids=[]\n    )\n    USERS[username] = Dict(:challenge => opts[\"challenge\"])\n    return HTTP.Response(200, [\"Content-Type\" => \"application/json\"],\n        JSON3.write(merge(opts, Dict(\"username\" => username))))\nend\nHTTP.register!(router, \"GET\", \"/webauthn/options/register\", serve_regoptions)\n\n# Registration finalize endpoint\nfunction serve_regfinish(req)\n    payload = JSON3.read(String(req.body))\n    username = get(payload, \"username\", \"\")\n    if isempty(username)\n        return HTTP.Response(400, [\"Content-Type\" => \"text/plain\"],\n            \"Missing username\")\n    end\n    chal = get(USERS[username], :challenge, nothing)\n    if chal === nothing\n        return HTTP.Response(400, [\"Content-Type\" => \"text/plain\"],\n            \"No challenge for username.\")\n    end\n    if !WebAuthn.verify_challenge(\n        payload[\"response\"][\"clientDataJSON\"], chal)\n        return HTTP.Response(400, [\"Content-Type\" => \"text/plain\"],\n            \"Challenge fail\")\n    end\n    attobj = WebAuthn.parse_attestation_object(\n        payload[\"response\"][\"attestationObject\"])\n    pkbytes = WebAuthn.extract_credential_public_key(attobj[\"authData\"])\n    cred_id = payload[\"id\"]\n    CREDENTIALS[cred_id] = Dict(\n        :public_key_cose => WebAuthn.base64urlencode(pkbytes),\n        :sign_count => 0,\n        :username => username\n    )\n    return HTTP.Response(200, [\"Content-Type\" => \"application/json\"],\n        JSON3.write(Dict(\"ok\" => true, \"username\" => username)))\nend\nHTTP.register!(router, \"POST\", \"/webauthn/register\", serve_regfinish)\n\n# Login options endpoint (now always records challenge per credential)\nfunction serve_loginoptions(req)\n    q = HTTP.queryparams(req)\n    username = get(q, \"username\", \"\")\n    allow_ids = String[]\n    if !isempty(username)\n        allow_ids = [cid for (cid, c) in CREDENTIALS if get(\n            c, :username, \"\") == username]\n        if isempty(allow_ids)\n            allow_ids = String[]\n        end\n    else\n        # usernameless/discoverable: allow ALL credential IDs\n        allow_ids = collect(keys(CREDENTIALS))\n    end\n    opts = WebAuthn.authentication_options(\"localhost\",\n        allow_credential_ids=allow_ids)\n    # Save this challenge to every involved credential:\n    for cid in allow_ids\n        CREDENTIALS[cid][:challenge] = opts[\"challenge\"]\n    end\n    return HTTP.Response(200, [\"Content-Type\" => \"application/json\"],\n        JSON3.write(merge(opts, Dict(\"username\" => username))))\nend\nHTTP.register!(router, \"GET\", \"/webauthn/options/login\", serve_loginoptions)\n\n# Login finalize endpoint (challenge fetched from credential now)\nfunction serve_loginfinish(req)\n    payload = JSON3.read(String(req.body))\n    credid = payload[\"id\"]\n    if !haskey(CREDENTIALS, credid)\n        return HTTP.Response(403, [\"Content-Type\" => \"text/plain\"],\n            \"Unknown credential\")\n    end\n    cred = CREDENTIALS[credid]\n    chal = get(cred, :challenge, nothing)\n    if chal === nothing\n        return HTTP.Response(400, [\"Content-Type\" => \"text/plain\"],\n            \"No challenge issued for this credential\")\n    end\n    if !WebAuthn.verify_challenge(payload[\"response\"][\"clientDataJSON\"], chal)\n        return HTTP.Response(400, [\"Content-Type\" => \"text/plain\"],\n            \"Challenge fail\")\n    end\n    pubkey = WebAuthn.cose_key_parse(\n        CBOR.decode(WebAuthn.base64urldecode(cred[:public_key_cose])))\n        ad = WebAuthn.base64urldecode(payload[\"response\"][\"authenticatorData\"])\n    cdj = WebAuthn.base64urldecode(payload[\"response\"][\"clientDataJSON\"])\n    sig = WebAuthn.base64urldecode(payload[\"response\"][\"signature\"])\n    cdj_dict = WebAuthn.parse_clientdata_json(payload[\"response\"][\"clientDataJSON\"])\n    ok = WebAuthn.verify_webauthn_signature(pubkey, ad, cdj, sig)\n    username = get(cred, :username, \"\")\n    if !ok\n        return HTTP.Response(403, [\"Content-Type\" => \"text/plain\"], \"Bad signature\")\n    end\n    verify_origin(cdj_dict, \"http://localhost:8000\")\n    old_signcount = cred[:sign_count]\n    new_signcount = reinterpret(UInt32, ad[34:37])[1]\n    enforce_signcount(old_signcount, new_signcount)\n    cred[:sign_count] = new_signcount\n    enforce_up_uv(ad; require_uv=false)\n    return HTTP.Response(200, [\"Content-Type\" => \"application/json\"],\n        JSON3.write(Dict(\"ok\" => true, \"username\" => username,\n            \"redirect\" => \"/login_success?username=$username\"))\n    )\nend\nHTTP.register!(router, \"POST\", \"/webauthn/login\", serve_loginfinish)\n\nsrv = HTTP.serve!(router, Sockets.localhost, 8000)","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#Contributions","page":"Home","title":"Contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Questions, issues, and PRs welcome!   See WebAuthn.jl on GitHub.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"#License","page":"Home","title":"License","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Licensed under the MIT License. See  LICENSE for details.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"}]
}
